### 1. 定义

每当创建一个Vue实例，就相当于创建一个`viewModel`监听器：**可以监听对应视图和对应数据的相互改变**

### 2. 使用

```js
let vm = new Vue({
	el: "选择器",
    data: {
        属性名: 属性值
    },
    methods: {
        属性名: 属性值
    }
})
```

`el`：即`element`——当前监听器监听的视图(**基于`querySelector`获取**)，相当于告诉`vue`，只处理当前视图下的内容。el不能是html和body这两个元素。

`data`：当前监听器监听的数据，这些监听的数据会挂载到`vm`实例上，也就是可以用`vm.xxx = xxx`来操作。当数据更新的时候，视图会自动更新。

`methods`：放视图中需要的方法。

注意：

- `data`上的属性和`methods`上的属性都会直接挂载在`vm`实例上；
- `methods`中的属性名和`data`中的属性名不能重复；
- `data`写得是vue变量，`methods`写得是`vm`实例中用到的方法；
- `methods`中的方法里面的`this`指向当前实例，`data`中的`this`不指向当前实例。

### 3. 小胡子语法——mustache

`{{数据变量}}`

- 只能编写表达式，变量、赋值表达式、执行函数、三元表达式等；
- 不能写语句，例如：for循环、if判断、switch、var等；
- 小胡子中最终展示的是表达式的结果；
- 在胡子语法中绑定的数据值是对象类型时，会基于`JSON.stringify`把其编译为字符串再呈现出来，而不是直接`toString`处理。

### 4. 视图自动渲染

#### 4.1 原理

vue数据更新，视图自动跟新的前提，是这个数据被vue劫持了，对应数据有get和set。并不是所有数据更改最后都会通知视图重新渲染。

#### 4.2 常见问题及解决方法

##### 4.2.1 情况1

初始数据是一个对象，对象中没有`xxx`键值对，后期新增的键值对是不会让视图重新渲染的，但是数据会改变。

##### 4.2.2 解决

- 增加一个无关变量，每次修改数据时，把这个无关变量也更新。例如：初始`t: 0`，更新数据时同时设置 `t = Math.random()`。原理：虽然没有自动渲染视图，但是数据已经改变，手动触发视图渲染。
- 最好在初始化数据时，就把视图需要的数据提前声明好。例如：`c: undefined`,可以是空值，但是要有这个属性。原理：**只有Data中初始化过的属性才有GET/SET**。
- 不要修改某个属性名，而是**把对象值整体替换（指向新的堆内存）**。原理：整个对象的替换，每一个后代属性都会被劫持。例如：可以使用`Object.assign()`,注意要把新对象放在前面，也可以用`...obj`,把原对象在新对象中展开。
- 可以基于`vm.$set`内置方法修改数据**vm.$set(对象，属性名，属性值)**
- `$forceUpdate`强制通知视图重新渲染，但是不会设置get和set

##### 4.2.3 情况2

如果数据是一个数组，我们修改数据基于`arr[n] = xxx`或者`arr.length`等操作方式，是无法让视图重新渲染的。

##### 4.2.4 解决

- `vm.$set`
- `push`、`pop`、`shift`、`unshift`、`splice`、`sort`、`reverse`，对于数组来说，能触发视图更新的，只有这几个数组的变异方法。
- 重写`arr`值（指向新的堆内存）

